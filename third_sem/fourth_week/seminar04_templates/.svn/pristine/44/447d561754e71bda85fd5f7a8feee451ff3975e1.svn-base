/*
    Основы строения std::vector

    Объекты класса std::vector хранят все объекты в куче, динамически выделяя место под них, если нужно.
    Примерно также, как это делают строки std::string.

    Сам объект std::vector обычно содержит 3 поля:

        T*      mpData     - указатель на данные в куче. 
        size_t  mSize      - размер, то есть количество элементов в векторе
        size_t  mCapacity  - вместимость, то есть сколько элементов вектор может хранить без
                             дополнительного выделения памяти.

    Также у вектора есть методы resize и reserve, которые позволяют наи самим изменить размер и вместимость.


    С одной стороны строение вектора во многом похоже на строение строки, которую мы писали на втором семинаре.
    Но с другой стороны, написать свой вектор значительно сложнее, так как вместо типа char мы теперь храним
    произвольный тип T. И у этого типа могут быть (или не быть) свои конструкторы и операторы присваивания.
*/

#include <iostream>
#include <vector>
#include <string>
using std::cout, std::endl;



int main()
{
    std::vector<int> v;

    cout << sizeof(v) << endl;

    for (int i = 0; i <= 300; ++i)
    {
        cout << "size = " << v.size() << ", capacity = " << v.capacity() << "\n";
        v.push_back(i);
    }

}


/*
    Задача:

        1)  Запустите эту программу и посмотрите во сколько раз увеличивается вместимость вектора при нехватки места.

        2)  Зарезервируйте необходимое место перед циклом, чтобы перевыделений памяти не происходило.
*/



