/*
    Раздельная компиляция

    Теперь мы разделим объявления и определения всех методов класса Point.
    Все объявления класса Point поместим в файл point.hpp, а определения методов в файл point.cpp.
    Таким образом у нас получилось 2 компилируемых файла: main.cpp и point.cpp и 1 заголовочный файл point.hpp.

    При этом заголовочный файл point.hpp должен подключаться везде, где используется класс Point.
    То есть в данном случае он должен подключаться и в файл main.cpp и в файл point.cpp.
    

    Для компиляции программы нужно указать компилятору на все компилируемые файлы вот так:

        g++ main.cpp point.cpp

    Если это не сделать и скомпилировать только файл main.cpp, то возникнет ошибка undefined reference to norm().
    Грубо говоря программа будет знать, что есть класс Point и знать его методы (так как это всё описано в point.hpp), 
    но любые попытки вызвать эти методы будут приводить к ошибке, так как они не были скомпилированы.


    Преемущество раздельной компиляции заключается в том, что компилировать разные .cpp файлы можно поотдельности.
    Представьте, что у вас огромный проект, содержащий тысячи файлов и миллионы строк кода. Такой проект может компилироваться часами.
    Теперь вы сделали небольшое изменение в одном файле этого проекта. Если бы нельзя было бы компилировать файлы поотдельности,
    то после любого изменения вам бы пришлось компилировать весь проект заново и ждать часы пока компиляция закончится.
    К счастью, .cpp файлы можно компилировать поотдельности и, если вы сделали изменение в одном файле, то скомпилировать
    потребуется только тот файл, который вы изменили.
*/



#include <iostream>
#include "point.hpp"

using std::cout, std::endl;

int main() 
{
    Point a = {7.2, 3.1};
    cout << a.norm() << endl;
}